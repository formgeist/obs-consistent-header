import { Field } from 'fp-ts/lib/Field';
import { Predicate } from 'fp-ts/lib/function';
import { Monoid } from 'fp-ts/lib/Monoid';
import { Ord } from 'fp-ts/lib/Ord';
import { Ring } from 'fp-ts/lib/Ring';
import { Semigroup } from 'fp-ts/lib/Semigroup';
import { Semiring } from 'fp-ts/lib/Semiring';
import { Setoid } from 'fp-ts/lib/Setoid';
import { Getter, Iso, Prism } from 'monocle-ts';
export interface Newtype<URI, A> {
    readonly _URI: URI;
    readonly _A: A;
}
export declare type AnyNewtype = Newtype<any, any>;
export declare type URIOf<N extends AnyNewtype> = N['_URI'];
export declare type CarrierOf<N extends AnyNewtype> = N['_A'];
/**
 * @deprecated use `CarrierOf` instead
 */
export declare type Carrier<N extends Newtype<any, any>> = N['_A'];
/** Lifts a function operate over newtypes */
export declare const over: <S extends Newtype<any, any>, T extends Newtype<any, any>>(f: (a: S["_A"]) => T["_A"]) => Getter<S, T>;
export declare const getSetoid: <S extends Newtype<any, any>>(S: Setoid<S["_A"]>) => Setoid<S>;
export declare const getOrd: <S extends Newtype<any, any>>(O: Ord<S["_A"]>) => Ord<S>;
export declare const getSemigroup: <S extends Newtype<any, any>>(S: Semigroup<S["_A"]>) => Semigroup<S>;
export declare const getMonoid: <S extends Newtype<any, any>>(M: Monoid<S["_A"]>) => Monoid<S>;
export declare const getSemiring: <S extends Newtype<any, any>>(S: Semiring<S["_A"]>) => Semiring<S>;
export declare const getRing: <S extends Newtype<any, any>>(R: Ring<S["_A"]>) => Ring<S>;
export declare const getField: <S extends Newtype<any, any>>(F: Field<S["_A"]>) => Field<S>;
export declare const unsafeCoerce: <A, B>(a: A) => B;
export declare const iso: <S extends Newtype<any, any>>() => Iso<S, S["_A"]>;
export interface Concat<N1 extends Newtype<object, any>, N2 extends Newtype<object, CarrierOf<N1>>> extends Newtype<URIOf<N1> & URIOf<N2>, CarrierOf<N1>> {
}
export interface Extends<N extends AnyNewtype, Tags extends object> extends Newtype<Tags & URIOf<N>, CarrierOf<N>> {
}
export declare const prism: <S extends Newtype<any, any>>(predicate: Predicate<S["_A"]>) => Prism<S["_A"], S>;
