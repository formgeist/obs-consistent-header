import { XDomain } from '../domains/x_domain';
import { YDomain } from '../domains/y_domain';
import { SeriesCollectionValue, FormattedDataSeries, SeriesIdentifier, RawDataSeries } from '../utils/series';
import { AxisSpec, BasicSeriesSpec, DomainRange, HistogramModeAlignment, Rotation } from '../utils/specs';
import { Theme } from '../../../utils/themes/theme';
import { Dimensions } from '../../../utils/dimensions';
import { Domain } from '../../../utils/domain';
import { GroupId, SpecId } from '../../../utils/ids';
import { Scale } from '../../../utils/scales/scales';
import { PointGeometry, BarGeometry, AreaGeometry, LineGeometry, IndexedGeometry } from '../../../utils/geometry';
import { LegendItem } from '../legend/legend';
import { Spec } from '../../../specs';
export interface Transform {
    x: number;
    y: number;
    rotate: number;
}
export interface BrushExtent {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
}
export interface GeometriesCounts {
    points: number;
    bars: number;
    areas: number;
    areasPoints: number;
    lines: number;
    linePoints: number;
}
export interface ComputedScales {
    xScale: Scale;
    yScales: Map<GroupId, Scale>;
}
export interface Geometries {
    points: PointGeometry[];
    bars: BarGeometry[];
    areas: AreaGeometry[];
    lines: LineGeometry[];
}
export interface ComputedGeometries {
    scales: ComputedScales;
    geometries: Geometries;
    geometriesIndex: Map<any, IndexedGeometry[]>;
    geometriesCounts: GeometriesCounts;
}
export interface SeriesDomainsAndData {
    xDomain: XDomain;
    yDomain: YDomain[];
    splittedDataSeries: RawDataSeries[][];
    formattedDataSeries: {
        stacked: FormattedDataSeries[];
        nonStacked: FormattedDataSeries[];
    };
    seriesCollection: Map<string, SeriesCollectionValue>;
}
/**
 * Adds or removes series from array or series
 * @param series
 * @param target
 */
export declare function updateDeselectedDataSeries(series: SeriesIdentifier[], target: SeriesIdentifier): SeriesIdentifier[];
/**
 * Return map assocition between `seriesKey` and only the custom colors string
 * @param seriesSpecs
 * @param seriesCollection
 * @param seriesColorOverrides color override from legend
 */
export declare function getCustomSeriesColors(seriesSpecs: BasicSeriesSpec[], seriesCollection: Map<string, SeriesCollectionValue>, seriesColorOverrides?: Map<string, string>): Map<string, string>;
export interface LastValues {
    y0: number | null;
    y1: number | null;
}
/**
 * Compute data domains for all specified specs.
 * @param seriesSpecs a map of all the series specs
 * @param customYDomainsByGroupId custom Y domains grouped by GroupId
 * @param customXDomain if specified in <Settings />, the custom X domain
 * @param deselectedDataSeries is optional; if not supplied,
 * then all series will be factored into computations. Otherwise, selectedDataSeries
 * is used to restrict the computation for just the selected series
 * @returns `SeriesDomainsAndData`
 */
export declare function computeSeriesDomains(seriesSpecs: BasicSeriesSpec[], customYDomainsByGroupId?: Map<GroupId, DomainRange>, deselectedDataSeries?: SeriesIdentifier[], customXDomain?: DomainRange | Domain): SeriesDomainsAndData;
export declare function computeSeriesGeometries(seriesSpecs: BasicSeriesSpec[], xDomain: XDomain, yDomain: YDomain[], formattedDataSeries: {
    stacked: FormattedDataSeries[];
    nonStacked: FormattedDataSeries[];
}, seriesColorMap: Map<string, string>, chartTheme: Theme, chartDims: Dimensions, chartRotation: Rotation, axesSpecs: AxisSpec[], enableHistogramMode: boolean): ComputedGeometries;
export declare function setBarSeriesAccessors(isHistogramMode: boolean, seriesSpecs: Map<SpecId, BasicSeriesSpec>): void;
export declare function isHistogramModeEnabled(seriesSpecs: BasicSeriesSpec[]): boolean;
export declare function computeXScaleOffset(xScale: Scale, enableHistogramMode: boolean, histogramModeAlignment?: HistogramModeAlignment): number;
export declare function getSpecsById<T extends Spec>(specs: T[], id: string): T | undefined;
export declare function getAxesSpecForSpecId(axesSpecs: AxisSpec[], groupId: GroupId): {
    xAxis: AxisSpec | undefined;
    yAxis: AxisSpec | undefined;
};
export declare function computeChartTransform(chartDimensions: Dimensions, chartRotation: Rotation): Transform;
/**
 * Merge multiple geometry indexes maps together.
 * @param iterables a set of maps to be merged
 * @returns a new Map where each element with the same key are concatenated on a single
 * IndexedGemoetry array for that key
 */
export declare function mergeGeometriesIndexes(...iterables: Map<any, IndexedGeometry[]>[]): Map<any, IndexedGeometry[]>;
export declare function isHorizontalRotation(chartRotation: Rotation): boolean;
export declare function isVerticalRotation(chartRotation: Rotation): boolean;
/**
 * Check if a specs map contains only line or area specs
 * @param specs Map<SpecId, BasicSeriesSpec>
 */
export declare function isLineAreaOnlyChart(specs: BasicSeriesSpec[]): boolean;
export declare function isChartAnimatable(geometriesCounts: GeometriesCounts, animationEnabled: boolean): boolean;
export declare function isAllSeriesDeselected(legendItems: Map<string, LegendItem>): boolean;
