import { XDomain } from '../domains/x_domain';
import { YDomain } from '../domains/y_domain';
import { AxisSpec, CompleteBoundedDomain, DomainRange, LowerBoundedDomain, Position, Rotation, UpperBoundedDomain, AxisStyle, TickFormatterOptions } from './specs';
import { AxisConfig, Theme } from '../../../utils/themes/theme';
import { Dimensions, Margins } from '../../../utils/dimensions';
import { AxisId } from '../../../utils/ids';
import { Scale } from '../../../utils/scales/scales';
import { BBox, BBoxCalculator } from '../../../utils/bbox/bbox_calculator';
export declare type AxisLinePosition = [number, number, number, number];
export interface AxisTick {
    value: number | string;
    label: string;
    position: number;
}
export interface AxisTicksDimensions {
    tickValues: string[] | number[];
    tickLabels: string[];
    maxLabelBboxWidth: number;
    maxLabelBboxHeight: number;
    maxLabelTextWidth: number;
    maxLabelTextHeight: number;
}
export interface TickLabelProps {
    x: number;
    y: number;
    align: string;
    verticalAlign: string;
}
/**
 * Compute the ticks values and identify max width and height of the labels
 * so we can compute the max space occupied by the axis component.
 * @param axisSpec the spec of the axis
 * @param xDomain the x domain associated
 * @param yDomain the y domain array
 * @param totalBarsInCluster the total number of grouped series
 * @param bboxCalculator an instance of the boundingbox calculator
 * @param chartRotation the rotation of the chart
 */
export declare function computeAxisTicksDimensions(axisSpec: AxisSpec, xDomain: XDomain, yDomain: YDomain[], totalBarsInCluster: number, bboxCalculator: BBoxCalculator, chartRotation: Rotation, axisConfig: AxisConfig, barsPadding?: number, enableHistogramMode?: boolean): AxisTicksDimensions | null;
export declare function getAxisTickLabelPadding(axisConfigTickLabelPadding: number, axisSpecStyle?: AxisStyle): number;
export declare function isYDomain(position: Position, chartRotation: Rotation): boolean;
export declare function getScaleForAxisSpec(axisSpec: AxisSpec, xDomain: XDomain, yDomain: YDomain[], totalBarsInCluster: number, chartRotation: Rotation, minRange: number, maxRange: number, barsPadding?: number, enableHistogramMode?: boolean): Scale | null;
export declare function computeRotatedLabelDimensions(unrotatedDims: BBox, degreesRotation: number): BBox;
export declare const getMaxBboxDimensions: (bboxCalculator: BBoxCalculator, fontSize: number, fontFamily: string, tickLabelRotation: number, tickLabelPadding: number) => (acc: {
    [key: string]: number;
}, tickLabel: string) => {
    maxLabelBboxWidth: number;
    maxLabelBboxHeight: number;
    maxLabelTextWidth: number;
    maxLabelTextHeight: number;
};
/**
 * The Konva api sets the top right corner of a shape as the default origin of rotation.
 * In order to apply rotation to tick labels while preserving their relative position to the axis,
 * we compute offsets to apply to the Text element as well as adjust the x/y coordinates to adjust
 * for these offsets.
 */
export declare function centerRotationOrigin(axisTicksDimensions: {
    maxLabelBboxWidth: number;
    maxLabelBboxHeight: number;
    maxLabelTextWidth: number;
    maxLabelTextHeight: number;
}, coordinates: {
    x: number;
    y: number;
}): {
    x: number;
    y: number;
    offsetX: number;
    offsetY: number;
};
/**
 * Gets the computed x/y coordinates & alignment properties for an axis tick label.
 * @param isVerticalAxis if the axis is vertical (in contrast to horizontal)
 * @param tickLabelRotation degree of rotation of the tick label
 * @param tickSize length of tick line
 * @param tickPadding amount of padding between label and tick line
 * @param tickPosition position of tick relative to axis line origin and other ticks along it
 * @param position position of where the axis sits relative to the visualization
 * @param axisTicksDimensions computed axis dimensions and values (from computeTickDimensions)
 */
export declare function getTickLabelProps(tickLabelRotation: number, tickSize: number, tickPadding: number, tickPosition: number, position: Position, axisPosition: Dimensions, axisTicksDimensions: AxisTicksDimensions): TickLabelProps;
export declare function getVerticalAxisTickLineProps(position: Position, axisWidth: number, tickSize: number, tickPosition: number): AxisLinePosition;
export declare function getHorizontalAxisTickLineProps(position: Position, axisHeight: number, tickSize: number, tickPosition: number): AxisLinePosition;
export declare function getVerticalAxisGridLineProps(tickPosition: number, chartWidth: number): AxisLinePosition;
export declare function getHorizontalAxisGridLineProps(tickPosition: number, chartHeight: number): AxisLinePosition;
export declare function getMinMaxRange(axisPosition: Position, chartRotation: Rotation, chartDimensions: Dimensions): {
    minRange: number;
    maxRange: number;
};
export declare function getAvailableTicks(axisSpec: AxisSpec, scale: Scale, totalBarsInCluster: number, enableHistogramMode: boolean, tickFormatOptions?: TickFormatterOptions): AxisTick[];
export declare function getVisibleTicks(allTicks: AxisTick[], axisSpec: AxisSpec, axisDim: AxisTicksDimensions): AxisTick[];
export declare function getAxisPosition(chartDimensions: Dimensions, chartMargins: Margins, axisTitleHeight: number, axisSpec: AxisSpec, axisDim: AxisTicksDimensions, cumTopSum: number, cumBottomSum: number, cumLeftSum: number, cumRightSum: number): {
    dimensions: {
        top: number;
        left: number;
        width: number;
        height: number;
    };
    topIncrement: number;
    bottomIncrement: number;
    leftIncrement: number;
    rightIncrement: number;
};
export declare function isVerticalAxis(axisPosition: Position): boolean;
export declare function isHorizontalAxis(axisPosition: Position): boolean;
export declare function isVerticalGrid(axisPosition: Position): boolean;
export declare function isHorizontalGrid(axisPosition: Position): boolean;
export declare function getAxisTicksPositions(computedChartDims: {
    chartDimensions: Dimensions;
    leftMargin: number;
}, chartTheme: Theme, chartRotation: Rotation, axisSpecs: AxisSpec[], axisDimensions: Map<AxisId, AxisTicksDimensions>, xDomain: XDomain, yDomain: YDomain[], totalGroupsCount: number, enableHistogramMode: boolean, barsPadding?: number): {
    axisPositions: Map<AxisId, Dimensions>;
    axisTicks: Map<AxisId, AxisTick[]>;
    axisVisibleTicks: Map<AxisId, AxisTick[]>;
    axisGridLinesPositions: Map<AxisId, AxisLinePosition[]>;
};
export declare function computeAxisGridLinePositions(isVerticalAxis: boolean, tickPosition: number, chartDimensions: Dimensions): AxisLinePosition;
export declare function isLowerBound(domain: Partial<CompleteBoundedDomain>): domain is LowerBoundedDomain;
export declare function isUpperBound(domain: Partial<CompleteBoundedDomain>): domain is UpperBoundedDomain;
export declare function isCompleteBound(domain: Partial<CompleteBoundedDomain>): domain is CompleteBoundedDomain;
export declare function isBounded(domain: Partial<CompleteBoundedDomain>): domain is DomainRange;
export declare const isDuplicateAxis: ({ position, title }: AxisSpec, { tickLabels }: AxisTicksDimensions, tickMap: Map<string, AxisTicksDimensions>, specs: AxisSpec[]) => boolean;
