import { Domain } from '../../../utils/domain';
import { ScaleType } from '../../../utils/scales/scales';
import { BasicSeriesSpec, DomainRange } from '../utils/specs';
import { BaseDomain } from './domain';
export declare type XDomain = BaseDomain & {
    type: 'xDomain';
    minInterval: number;
    /** if x domain is time, we should also specify the timezone */
    timeZone?: string;
};
/**
 * Merge X domain value between a set of chart specification.
 * @param specs an array of [{ seriesType, xScaleType }]
 * @param xValues a set of unique x values from all specs
 * @param customXDomain if specified, a custom xDomain
 * @returns a merged XDomain between all series.
 */
export declare function mergeXDomain(specs: Pick<BasicSeriesSpec, 'seriesType' | 'xScaleType'>[], xValues: Set<string | number>, customXDomain?: DomainRange | Domain): XDomain;
/**
 * Find the minimum interval between xValues.
 * Default to 0 if an empty array, 1 if one item array
 */
export declare function findMinInterval(xValues: number[]): number;
/**
 * Convert the scale types of a set of specification to a generic one.
 * If there are at least one `ordinal` scale type, the resulting scale is coerched to ordinal.
 * If there are only `continuous` scale types, the resulting scale is coerched to linear.
 * If there are only `time` scales, we coerch the timeZone to `utc` only if we have multiple
 * different timezones.
 * @returns the coerched scale type, the timezone and a parameter that describe if its a bandScale or not
 */
export declare function convertXScaleTypes(specs: Pick<BasicSeriesSpec, 'seriesType' | 'xScaleType' | 'timeZone'>[]): {
    scaleType: ScaleType;
    isBandScale: boolean;
    timeZone?: string;
} | null;
