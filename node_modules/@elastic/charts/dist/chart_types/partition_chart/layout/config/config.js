"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var palettes_1 = require("../../../../mocks/hierarchical/palettes");
var config_types_1 = require("../types/config_types");
var math_1 = require("../utils/math");
var types_1 = require("../types/types");
var log10 = Math.log(10);
function significantDigitCount(d) {
    var n = Math.abs(parseFloat(String(d).replace('.', ''))); //remove decimal and make positive
    if (n == 0)
        return 0;
    while (n != 0 && n % 10 == 0)
        n /= 10;
    return Math.floor(Math.log(n) / log10) + 1;
}
function defaultFormatter(d) {
    return typeof d === 'string'
        ? d
        : typeof d === 'number'
            ? Math.abs(d) >= 10000000 || Math.abs(d) < 0.001
                ? d.toExponential(Math.min(2, Math.max(0, significantDigitCount(d) - 1)))
                : d.toLocaleString(void 0, {
                    maximumSignificantDigits: 4,
                    maximumFractionDigits: 3,
                    useGrouping: true,
                })
            : String(d);
}
var valueFont = {
    type: 'group',
    values: {
        /*
        // Object.assign interprets the extant `undefined` as legit, so commenting it out till moving away from Object.assign in `const valueFont = ...`
        fontFamily: {
          dflt: undefined,
          type: 'string',
        },
       */
        fontWeight: { dflt: 400, min: 100, max: 900, type: 'number' },
        fontStyle: {
            dflt: 'normal',
            type: 'string',
            values: types_1.FONT_STYLES,
        },
        fontVariant: {
            dflt: 'normal',
            type: 'string',
            values: types_1.FONT_VARIANTS,
        },
    },
};
exports.configMetadata = {
    // shape geometry
    width: { dflt: 300, min: 0, max: 1024, type: 'number', reconfigurable: false },
    height: { dflt: 150, min: 0, max: 1024, type: 'number', reconfigurable: false },
    margin: {
        type: 'group',
        values: {
            left: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
            right: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
            top: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
            bottom: { dflt: 0, min: -0.25, max: 0.25, type: 'number' },
        },
    },
    outerSizeRatio: new config_types_1.Numeric({
        dflt: 1 / math_1.GOLDEN_RATIO,
        min: 0.25,
        max: 1,
        reconfigurable: true,
        documentation: 'The diameter of the entire circle, relative to the smaller of the usable rectangular size (smaller of width/height minus the margins)',
    }),
    emptySizeRatio: new config_types_1.Numeric({
        dflt: 0,
        min: 0,
        max: 0.8,
        reconfigurable: true,
        documentation: 'The diameter of the inner circle, relative to `outerSizeRatio`',
    }),
    clockwiseSectors: {
        dflt: true,
        type: 'boolean',
        documentation: 'Largest to smallest sectors are positioned in a clockwise order',
    },
    specialFirstInnermostSector: {
        dflt: true,
        type: 'boolean',
        documentation: 'Starts placement with the second largest slice, for the innermost pie/ring',
    },
    // general text config
    fontFamily: {
        dflt: 'Sans-Serif',
        type: 'string',
    },
    // fill text config
    minFontSize: { dflt: 8, min: 0.1, max: 8, type: 'number', reconfigurable: true },
    maxFontSize: { dflt: 64, min: 0.1, max: 64, type: 'number' },
    idealFontSizeJump: {
        dflt: 1.05,
        min: 1.05,
        max: math_1.GOLDEN_RATIO,
        type: 'number',
        reconfigurable: false,
    },
    partitionLayout: {
        dflt: config_types_1.PartitionLayout.sunburst,
        type: 'string',
        values: Object.keys(config_types_1.PartitionLayout),
    },
    // fill text layout config
    circlePadding: { dflt: 2, min: 0, max: 8, type: 'number' },
    radialPadding: { dflt: math_1.TAU / 360, min: 0.0, max: 0.035, type: 'number' },
    horizontalTextAngleThreshold: { dflt: math_1.TAU / 12, min: 0, max: math_1.TAU, type: 'number' },
    horizontalTextEnforcer: { dflt: 1, min: 0, max: 1, type: 'number' },
    maxRowCount: { dflt: 12, min: 1, max: 16, type: 'number' },
    fillOutside: { dflt: false, type: 'boolean' },
    radiusOutside: { dflt: 128, min: 0, max: 1024, type: 'number' },
    fillRectangleWidth: { dflt: Infinity, reconfigurable: false, type: 'number' },
    fillRectangleHeight: { dflt: Infinity, reconfigurable: false, type: 'number' },
    fillLabel: {
        type: 'group',
        values: {
            textColor: { dflt: '#000000', type: 'color' },
            textInvertible: { dflt: false, type: 'boolean' },
            fontWeight: { dflt: 400, min: 100, max: 900, type: 'number' },
            fontStyle: {
                dflt: 'normal',
                type: 'string',
                values: types_1.FONT_STYLES,
            },
            fontVariant: {
                dflt: 'normal',
                type: 'string',
                values: types_1.FONT_VARIANTS,
            },
            valueFormatter: {
                dflt: defaultFormatter,
                type: 'function',
            },
            valueFont: valueFont,
        },
    },
    // linked labels (primarily: single-line)
    linkLabel: {
        type: 'group',
        values: {
            maximumSection: {
                dflt: 10,
                min: 0,
                max: 10000,
                type: 'number',
                reconfigurable: true,
                documentation: 'Uses linked labels below this limit of the outer sector arc length (in pixels)',
            },
            fontSize: { dflt: 12, min: 4, max: 32, type: 'number' },
            gap: { dflt: 10, min: 6, max: 16, type: 'number' },
            spacing: { dflt: 2, min: 0, max: 16, type: 'number' },
            horizontalStemLength: { dflt: 10, min: 6, max: 16, type: 'number' },
            radiusPadding: { dflt: 10, min: 6, max: 16, type: 'number' },
            lineWidth: { dflt: 1, min: 0.1, max: 2, type: 'number' },
            maxCount: {
                dflt: 36,
                min: 2,
                max: 64,
                type: 'number',
                documentation: 'Limits the total count of linked labels. The first N largest slices are kept.',
            },
            textColor: { dflt: '#000000', type: 'color' },
            textInvertible: { dflt: false, type: 'boolean' },
            textOpacity: { dflt: 1, min: 0, max: 1, type: 'number' },
            minimumStemLength: {
                dflt: 0,
                min: 0,
                max: 16,
                type: 'number',
                reconfigurable: false,
            },
            stemAngle: {
                dflt: math_1.TAU / 8,
                min: 0,
                max: math_1.TAU,
                type: 'number',
                reconfigurable: false,
            },
            valueFont: valueFont,
        },
    },
    // other
    backgroundColor: { dflt: '#ffffff', type: 'color' },
    sectorLineWidth: { dflt: 1, min: 0, max: 4, type: 'number' },
    colors: { dflt: 'turbo', type: 'palette', values: Object.keys(palettes_1.palettes) },
    palettes: { dflt: palettes_1.palettes, type: 'palettes', reconfigurable: false },
};
// todo switch to `io-ts` style, generic way of combining static and runtime type info
function configMap(mapper, configMetadata) {
    var result = Object.assign.apply(Object, __spread([{}], Object.entries(configMetadata).map(function (_a) {
        var _b, _c;
        var _d = __read(_a, 2), k = _d[0], v = _d[1];
        if (v.type === 'group') {
            return _b = {}, _b[k] = configMap(mapper, v.values), _b;
        }
        else {
            return _c = {}, _c[k] = mapper(v), _c;
        }
    })));
    return result;
}
exports.config = configMap(function (item) { return item.dflt; }, exports.configMetadata);
//# sourceMappingURL=config.js.map