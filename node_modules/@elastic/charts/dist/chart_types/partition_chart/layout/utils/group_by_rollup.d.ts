import { Relation } from '../types/types';
export declare const AGGREGATE_KEY = "value";
export declare const DEPTH_KEY = "depth";
export declare const CHILDREN_KEY = "children";
export declare const PARENT_KEY = "parent";
export declare const SORT_INDEX_KEY = "sortIndex";
interface NodeDescriptor {
    [AGGREGATE_KEY]: number;
    [DEPTH_KEY]: number;
}
export declare type ArrayEntry = [Key, ArrayNode];
export declare type HierarchyOfArrays = Array<ArrayEntry>;
export interface ArrayNode extends NodeDescriptor {
    [CHILDREN_KEY]: HierarchyOfArrays;
    [PARENT_KEY]: ArrayNode;
    [SORT_INDEX_KEY]: number;
}
declare type HierarchyOfMaps = Map<Key, MapNode>;
interface MapNode extends NodeDescriptor {
    [CHILDREN_KEY]?: HierarchyOfMaps;
    [PARENT_KEY]?: ArrayNode;
}
export declare type PrimitiveValue = string | number | null;
declare type Key = PrimitiveValue;
declare type Sorter = (a: number, b: number) => number;
declare type NodeSorter = (a: ArrayEntry, b: ArrayEntry) => number;
export declare type Tuple = Record<string, any>;
export declare const entryKey: ([key]: ArrayEntry) => string | number | null;
export declare const entryValue: ([, value]: ArrayEntry) => ArrayNode;
export declare function depthAccessor(n: ArrayEntry): number;
export declare function aggregateAccessor(n: ArrayEntry): number;
export declare function parentAccessor(n: ArrayEntry): ArrayNode;
export declare function childrenAccessor(n: ArrayEntry): HierarchyOfArrays;
export declare function sortIndexAccessor(n: ArrayEntry): number;
export declare function groupByRollup(keyAccessors: Array<((a: Tuple) => Key) | ((a: Tuple, i: number) => Key)>, valueAccessor: Function, { reducer, identity, }: {
    reducer: (prev: number, next: number) => number;
    identity: Function;
}, factTable: Relation): HierarchyOfMaps;
export declare function mapsToArrays(root: HierarchyOfMaps, sorter: NodeSorter): HierarchyOfArrays;
export declare function mapEntryValue(entry: ArrayEntry): number;
export declare function aggregateComparator(accessor: Function, sorter: Sorter): NodeSorter;
export declare const childOrders: {
    ascending: Sorter;
    descending: Sorter;
};
export declare const aggregators: {
    one: {
        identity: () => number;
        reducer: () => number;
    };
    count: {
        identity: () => number;
        reducer: (r: number) => number;
    };
    sum: {
        identity: () => number;
        reducer: (r: number, n: number) => number;
    };
    min: {
        identity: () => number;
        reducer: (r: number, n: number) => number;
    };
    max: {
        identity: () => number;
        reducer: (r: number, n: number) => number;
    };
    min0: {
        identity: () => number;
        reducer: (r: number, n: number) => number;
    };
    max0: {
        identity: () => number;
        reducer: (r: number, n: number) => number;
    };
};
export {};
