import { ArrayEntry } from '../utils/group_by_rollup';
export declare type Color = string;
export declare const FONT_VARIANTS: readonly ["normal", "small-caps"];
export declare type FontVariant = typeof FONT_VARIANTS[number];
export declare const FONT_WEIGHTS: readonly [100, 200, 300, 400, 500, 600, 700, 800, 900, "normal", "bold", "lighter", "bolder", "inherit", "initial", "unset"];
export declare type FontWeight = typeof FONT_WEIGHTS[number];
export declare type NumericFontWeight = number & typeof FONT_WEIGHTS[number];
export declare const FONT_STYLES: readonly ["normal", "italic", "oblique", "inherit", "initial", "unset"];
export declare type FontStyle = typeof FONT_STYLES[number];
/** todo consider doing tighter control for permissible font families, eg. as in Kibana Canvas - expression language
 *  - though the same applies for permissible (eg. known available or loaded) font weights, styles, variants...
 */
export declare type FontFamily = string;
export interface Font {
    fontStyle: FontStyle;
    fontVariant: FontVariant;
    fontWeight: FontWeight;
    fontFamily: FontFamily;
}
export declare type PartialFont = Partial<Font>;
export interface Box extends Font {
    text: string;
}
export declare type TextMeasure = (fontSize: number, boxes: Box[]) => TextMetrics[];
/**
 * Part-to-whole visualizations such as treemap, sunburst, pie hinge on an aggregation
 * function such that the value is independent of the order of how the constituents are aggregated
 * https://en.wikipedia.org/wiki/Associative_property
 * Hierarchical, space-filling part-to-whole visualizations also need that the
 * the value of a node is equal to the sum of the values of its children
 * https://mboehm7.github.io/teaching/ss19_dbs/04_RelationalAlgebra.pdf p21
 * It's now `count` and `sum` but subject to change
 */
export declare type AdditiveAggregation = 'count' | 'sum';
export declare type Relation = Array<object>;
export interface Origin {
    x0: number;
    y0: number;
}
export interface Rectangle extends Origin {
    x1: number;
    y1: number;
}
export interface Part extends Rectangle {
    node: ArrayEntry;
}
