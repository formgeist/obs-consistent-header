"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var link_text_layout_1 = require("./link_text_layout");
var config_types_1 = require("../types/config_types");
var math_1 = require("../utils/math");
var geometry_1 = require("../geometry");
var treemap_1 = require("../utils/treemap");
var sunburst_1 = require("../utils/sunburst");
var d3_utils_1 = require("../utils/d3_utils");
var fill_text_layout_1 = require("./fill_text_layout");
var group_by_rollup_1 = require("../utils/group_by_rollup");
function paddingAccessor(n) {
    return group_by_rollup_1.entryValue(n).depth > 1 ? 1 : [0, 2][group_by_rollup_1.entryValue(n).depth];
}
function rectangleFillOrigins(n) {
    return [(n.x0 + n.x1) / 2, (n.y0 + n.y1) / 2];
}
exports.ringSectorInnerRadius = function (n) { return n.y0px; };
exports.ringSectorOuterRadius = function (n) { return n.y1px; };
exports.ringSectorMiddleRadius = function (n) { return n.yMidPx; };
function sectorFillOrigins(fillOutside) {
    return function (node) {
        var midAngle = (node.x0 + node.x1) / 2;
        var divider = 10;
        var innerBias = fillOutside ? 9 : 1;
        var outerBias = divider - innerBias;
        // prettier-ignore
        var radius = (innerBias * exports.ringSectorInnerRadius(node)
            + outerBias * exports.ringSectorOuterRadius(node))
            / divider;
        var cx = Math.cos(math_1.trueBearingToStandardPositionAngle(midAngle)) * radius;
        var cy = Math.sin(math_1.trueBearingToStandardPositionAngle(midAngle)) * radius;
        return [cx, cy];
    };
}
function makeQuadViewModel(childNodes, layers, sectorLineWidth) {
    return childNodes.map(function (node) {
        var opacityMultiplier = 1; // could alter in the future, eg. in response to interactions
        var layer = layers[node.depth - 1];
        var fillColorSpec = layer && layer.shape && layer.shape.fillColor;
        var fill = fillColorSpec || 'rgba(128,0,0,0.5)';
        var shapeFillColor = typeof fill === 'function' ? fill(node, node.sortIndex, node.parent.children) : fill;
        var _a = d3_utils_1.stringToRGB(shapeFillColor), r = _a.r, g = _a.g, b = _a.b, opacity = _a.opacity;
        var fillColor = d3_utils_1.argsToRGBString(r, g, b, opacity * opacityMultiplier);
        var strokeWidth = sectorLineWidth;
        return __assign({ strokeWidth: strokeWidth, fillColor: fillColor }, node);
    });
}
exports.makeQuadViewModel = makeQuadViewModel;
function makeOutsideLinksViewModel(outsideFillNodes, rowSets, linkLabelRadiusPadding) {
    return outsideFillNodes
        .map(function (node, i) {
        var rowSet = rowSets[i];
        if (!rowSet.rows.reduce(function (p, row) { return p + row.rowWords.length; }, 0))
            return { points: [] };
        var radius = exports.ringSectorOuterRadius(node);
        var midAngle = math_1.trueBearingToStandardPositionAngle(geometry_1.meanAngle(node.x0, node.x1));
        var cos = Math.cos(midAngle);
        var sin = Math.sin(midAngle);
        var x0 = cos * radius;
        var y0 = sin * radius;
        var x = cos * (radius + linkLabelRadiusPadding);
        var y = sin * (radius + linkLabelRadiusPadding);
        return {
            points: [
                [x0, y0],
                [x, y],
            ],
        };
    })
        .filter(function (_a) {
        var points = _a.points;
        return points.length > 1;
    });
}
exports.makeOutsideLinksViewModel = makeOutsideLinksViewModel;
// todo break up this long function
function shapeViewModel(textMeasure, config, layers, facts, rawTextGetter, valueAccessor, valueFormatter, groupByRollupAccessors) {
    var width = config.width, height = config.height, margin = config.margin, emptySizeRatio = config.emptySizeRatio, outerSizeRatio = config.outerSizeRatio, fillOutside = config.fillOutside, linkLabel = config.linkLabel, clockwiseSectors = config.clockwiseSectors, specialFirstInnermostSector = config.specialFirstInnermostSector, minFontSize = config.minFontSize, partitionLayout = config.partitionLayout;
    var innerWidth = width * (1 - Math.min(1, margin.left + margin.right));
    var innerHeight = height * (1 - Math.min(1, margin.top + margin.bottom));
    var diskCenter = {
        x: width * margin.left + innerWidth / 2,
        y: height * margin.top + innerHeight / 2,
    };
    var aggregator = group_by_rollup_1.aggregators.sum;
    // don't render anything if there are no tuples, or some are negative, or the total is not positive
    if (facts.length === 0 ||
        facts.some(function (n) { return valueAccessor(n) < 0; }) ||
        facts.reduce(function (p, n) { return aggregator.reducer(p, valueAccessor(n)); }, aggregator.identity()) <= 0) {
        return {
            config: config,
            diskCenter: diskCenter,
            quadViewModel: [],
            rowSets: [],
            linkLabelViewModels: [],
            outsideLinksViewModel: [],
        };
    }
    // We can precompute things invariant of how the rectangle is divvied up.
    // By introducing `scale`, we no longer need to deal with the dichotomy of
    // size as data value vs size as number of pixels in the rectangle
    var tree = group_by_rollup_1.mapsToArrays(group_by_rollup_1.groupByRollup(groupByRollupAccessors, valueAccessor, aggregator, facts), group_by_rollup_1.aggregateComparator(group_by_rollup_1.mapEntryValue, group_by_rollup_1.childOrders.descending));
    var totalValue = tree.reduce(function (p, n) { return p + group_by_rollup_1.mapEntryValue(n); }, 0);
    var sunburstValueToAreaScale = math_1.TAU / totalValue;
    var sunburstAreaAccessor = function (e) { return sunburstValueToAreaScale * group_by_rollup_1.mapEntryValue(e); };
    var treemapLayout = partitionLayout === config_types_1.PartitionLayout.treemap;
    var treemapInnerArea = treemapLayout ? width * height : 1; // assuming 1 x 1 unit square
    var treemapValueToAreaScale = treemapInnerArea / totalValue;
    var treemapAreaAccessor = function (e) { return treemapValueToAreaScale * group_by_rollup_1.mapEntryValue(e); };
    var rawChildNodes = treemapLayout
        ? treemap_1.treemap(tree, treemapAreaAccessor, paddingAccessor, { x0: -width / 2, y0: -height / 2, width: width, height: height })
        : sunburst_1.sunburst(tree, sunburstAreaAccessor, { x0: 0, y0: -1 }, clockwiseSectors, specialFirstInnermostSector);
    // use the smaller of the two sizes, as a circle fits into a square
    var circleMaximumSize = Math.min(innerWidth, innerHeight);
    var outerRadius = (outerSizeRatio * circleMaximumSize) / 2;
    var innerRadius = outerRadius - (1 - emptySizeRatio) * outerRadius;
    var treeHeight = rawChildNodes.reduce(function (p, n) { return Math.max(p, group_by_rollup_1.entryValue(n.node).depth); }, 0); // 1: pie, 2: two-ring donut etc.
    var ringThickness = (outerRadius - innerRadius) / treeHeight;
    var quadViewModel = makeQuadViewModel(rawChildNodes.slice(1).map(function (n) {
        var node = n.node;
        return {
            dataName: group_by_rollup_1.entryKey(node),
            depth: group_by_rollup_1.depthAccessor(node),
            value: group_by_rollup_1.aggregateAccessor(node),
            parent: group_by_rollup_1.parentAccessor(node),
            sortIndex: group_by_rollup_1.sortIndexAccessor(node),
            x0: n.x0,
            x1: n.x1,
            y0: n.y0,
            y1: n.y1,
            y0px: treemapLayout ? n.y0 : innerRadius + n.y0 * ringThickness,
            y1px: treemapLayout ? n.y1 : innerRadius + n.y1 * ringThickness,
            yMidPx: treemapLayout ? (n.y0 + n.y1) / 2 : innerRadius + ((n.y0 + n.y1) / 2) * ringThickness,
        };
    }), layers, config.sectorLineWidth);
    // fill text
    var roomCondition = function (n) {
        var diff = n.x1 - n.x0;
        return treemapLayout
            ? n.x1 - n.x0 > minFontSize && n.y1px - n.y0px > minFontSize
            : (diff < 0 ? math_1.TAU + diff : diff) * exports.ringSectorMiddleRadius(n) > Math.max(minFontSize, linkLabel.maximumSection);
    };
    var nodesWithRoom = quadViewModel.filter(roomCondition);
    var outsideFillNodes = fillOutside && !treemapLayout ? nodesWithRoom : [];
    var textFillOrigins = nodesWithRoom.map(treemapLayout ? rectangleFillOrigins : sectorFillOrigins(fillOutside));
    var rowSets = fill_text_layout_1.fillTextLayout(textMeasure, rawTextGetter, valueFormatter, nodesWithRoom, config, layers, textFillOrigins, treemapLayout ? fill_text_layout_1.rectangleConstruction : fill_text_layout_1.ringSectorConstruction(config, innerRadius, ringThickness), treemapLayout ? fill_text_layout_1.getRectangleRowGeometry : fill_text_layout_1.getSectorRowGeometry, treemapLayout ? function () { return 0; } : fill_text_layout_1.inSectorRotation(config.horizontalTextEnforcer, config.horizontalTextAngleThreshold));
    // whiskers (ie. just lines, no text) for fill text outside the outer radius
    var outsideLinksViewModel = makeOutsideLinksViewModel(outsideFillNodes, rowSets, linkLabel.radiusPadding);
    // linked text
    var currentY = [-height, -height, -height, -height];
    var nodesWithoutRoom = fillOutside || treemapLayout
        ? [] // outsideFillNodes and linkLabels are in inherent conflict due to very likely overlaps
        : quadViewModel.filter(function (n) {
            var id = fill_text_layout_1.nodeId(n);
            var foundInFillText = rowSets.find(function (r) { return r.id === id; });
            // successful text render if found, and has some row(s)
            return !(foundInFillText && foundInFillText.rows.length !== 0);
        });
    var linkLabelViewModels = link_text_layout_1.linkTextLayout(textMeasure, config, nodesWithoutRoom, currentY, outerRadius, rawTextGetter, valueFormatter);
    // combined viewModel
    return {
        config: config,
        diskCenter: diskCenter,
        quadViewModel: quadViewModel,
        rowSets: rowSets,
        linkLabelViewModels: linkLabelViewModels,
        outsideLinksViewModel: outsideLinksViewModel,
    };
}
exports.shapeViewModel = shapeViewModel;
//# sourceMappingURL=viewmodel.js.map