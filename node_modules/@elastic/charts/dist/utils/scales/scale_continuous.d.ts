import { ScaleContinuousType, ScaleType, Scale } from './scales';
/**
 * As log(0) = -Infinite, a log scale domain must be strictly-positive
 * or strictly-negative; the domain must not include or cross zero value.
 * We need to limit the domain scale to the right value on all possible cases.
 * @param domain the domain to limit
 */
export declare function limitLogScaleDomain(domain: any[]): any[];
interface ScaleData {
    /** The Type of continuous scale */
    type: ScaleContinuousType;
    /** The data input domain */
    domain: any[];
    /** The data output range */
    range: [number, number];
}
interface ScaleOptions {
    /**
     * The desidered bandwidth for a linear band scale.
     * @default 0
     */
    bandwidth: number;
    /**
     * The min interval computed on the XDomain. Not available for yDomains.
     * @default 0
     */
    minInterval: number;
    /**
     * A time zone identifier. Can be any IANA zone supported by he host environment,
     * or a fixed-offset name of the form 'utc+3', or the strings 'local' or 'utc'.
     * @default 'utc'
     */
    timeZone: string;
    /**
     * The number of bars in the cluster. Used to correctly compute scales when
     * using padding between bars.
     * @default 1
     */
    totalBarsInCluster: number;
    /**
     * The proportion of the range that is reserved for blank space between bands
     * A number between 0 and 1.
     * @default 0
     */
    barsPadding: number;
    /**
     * The approximated number of ticks.
     * @default 10
     */
    ticks: number;
    /** true if the scale was adjusted to fit one single value histogram */
    isSingleValueHistogram: boolean;
    /** Show only integer values **/
    integersOnly?: boolean;
}
export declare class ScaleContinuous implements Scale {
    readonly bandwidth: number;
    readonly totalBarsInCluster: number;
    readonly bandwidthPadding: number;
    readonly minInterval: number;
    readonly step: number;
    readonly type: ScaleType;
    readonly domain: any[];
    readonly range: number[];
    readonly isInverted: boolean;
    readonly tickValues: number[];
    readonly timeZone: string;
    readonly barsPadding: number;
    readonly isSingleValueHistogram: boolean;
    private readonly d3Scale;
    constructor(scaleData: ScaleData, options?: Partial<ScaleOptions>);
    getTicks(ticks: number, integersOnly: boolean): number[];
    scale(value: any): any;
    pureScale(value: any): any;
    ticks(): number[];
    invert(value: number): number;
    invertWithStep(value: number, data: number[]): {
        value: number;
        withinBandwidth: boolean;
    } | null;
    isSingleValue(): boolean;
    isValueInDomain(value: number): boolean;
}
export declare function isLogarithmicScale(scale: Scale): boolean;
export {};
